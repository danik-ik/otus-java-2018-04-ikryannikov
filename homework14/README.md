# Домашнее задание №14

Многопоточная сортировка

Написать приложение, которое сортирует массив чисел в 4 потоках с использованием библиотеки или без нее.

### Комментарии

Реализоване сортировка слиянием. Массив предварительно разделяется на фрагменты указанного при вызове максимального размера, которые сортируются стандартными средствами. Затем они попарно сливаются с сохранением порядка от меньшего к большему. Слияние производится до тех пор, пока в результате не останется один фрагмент, который и будет отсортированным массивом.

Сортировка производится без изменения исходного массива. Соответственно, требуется дополнительный объём памяти, двукратно превышающий размер исходного массива (сортировка производится слоями, соответственно, требуется память на два смежных слоя с максимальным размером данных как у исходного массива на каждый слой).

Используется пул потоков из java.util.concurrent.

Все задания (разделение на предварительно отсортированные фрагменты и попарное слияние фрагментов) выполняется асинхронно. Соответственно, метод слияния получает в качестве исходных данных два объекта Future<int[]>. Если один или оба из аргументор не готовы, приходится ожидать (yield). Соответственно, при большом количестве потоков на последних итерациях (одно задание на последней, одно или два на предпоследней, три или четыре на предпредпоследней итерации) потоки начинают простаивать в ожидании завершения предыдущих заданий.

Результат можно получить асинхронно, в виде Future<int[]> (````public Future<int[]> getSortFuture(int[] source)````) или синхронно, дождавшись завершения (````public int[] sort(int[] source)````)

Следует иметь в виду, что наивная оценка времени выполнения -- это сравнение тёплого с мягким, так как TreadSorter производит сортировку без изменения исходного массива, а Arrays.sort сортирует массив на месте. Тем не менее, при определённых условиях TreadSort показывает сопоставимое или даже чуть лучшее время выполнения :) (но это не точно, при таких-то методах измерения)