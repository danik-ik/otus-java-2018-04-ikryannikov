# Домашнее задание №11

my cache engine

Напишите свой cache engine с soft references.
Добавьте кэширование в DBService из заданий myORM или Hibernate ORM

### Комментарии

Не захотел тупо переписывать учебный пример, доработал интерфейс с точки зрения упрощения использования. Зато если из кэша что-то получено -- то это уже законная strong ссылка, которая точно не испортится через пару строк, как могло бы быть при передаче наружу CacheEntry c soft-ссылкой. 

Обобщил использование строгих/нестрогих ссылок, приравняв null к промаху кэша (см. ниже  раздел "ограничения"), и выделил интерфейс для CacheEntry. Кэш при создании   получает фабрику для CacheEntry. Фобрика может формировать CacheEntry с любым видом сылок, хоть вперемешку. Есть хелпер, предоставляющий типовые фабрики для строгих и soft ссылок.

Для кэширования данных при использовании DBService создан декоратор. 

Для регрессного тестирования с возможностью локализации проблем на уровне кэша созданный ранее тест продублирован (параметризацией) в вариантах с различными фабриками для DBService - с кэшем и без кэша. Тесты не являются независимыми, это скорее интеграционные тесты, показывающие отсутствие поломки при введении кэша.

Для проверки функционала Soft-ссылок производится попытка заполнить кэш объектами с общим размером, в два раза превышающим имеющийся общий объём памяти. Соответственно, часть ссылок в процессе заполнения отваливается. Проверка упрощённая, производится попытка чтения из кэша по всем внесённым ключам, после чего проверяется только ниличие промахов (отвалившихся ссылок) и попаданий. Тест не очень быстрый (и скорость зависит от объёма памяти), но как иначе показать, что на кэшируемые объекты есть soft-ссылки и нет строгих ссылок, я не придумал.

Собственно факты кэширования проверяются на эмуляторе DBService с подсчётом обращений к методу Get. Сам эмулятор тоже проверяется, а то всякое в жизни бывало.

То, что в образце было в методе main, перенёс в тесты. Удалять не стал, хотя они ничего не тестируют на самом деле. Пусть будет.

#### Ограничения

Поскольку предусмотрена прозрачная работа с Soft-ссылками, значения null не могут быть эффективно кэшированы, поэтому они вообще не помещаются в кэш (и удаляются, если извлекаются из кэша, так как это может означать отвалившуюся soft-ссылку). Получение из кэша наружу значения null равно может обозначать промах кэша или устаревшую ссылку (что тоже промах). И  то, и другое провоцирует обращение к внешнему хранилищу в методе getOrCalculate.

При необходимости сохранения в кэше информации об отсутствии объекта во внешнем хранилище можно использовать null object.